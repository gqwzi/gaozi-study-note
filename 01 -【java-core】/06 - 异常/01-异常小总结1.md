今天我介绍了 Java 虚拟机的异常处理机制。
【小结】
Java 的异常分为 Exception 和 Error 两种，而 Exception 又分为 RuntimeException 和其他类 型。RuntimeException 和 Error 属于非检查异常。其他的 Exception 皆属于检查异常，在触发时需 要显式捕获，或者在方法头用 throws 关键字声明。
Java 字节码中，每个方法对应一个异常表。当程序触发异常时，Java 虚拟机将查找异常表，并依此 决定需要将控制流转移至哪个异常处理器之中。Java 代码中的 catch 代码块和 fnally 代码块都会生 成异常表条目。

【总结】
- 0：既然异常实例的构造十分昂贵，我们是否可以缓存异常实例，在需要用到的时候直接抛出呢?       
答案：从语 法角度上来看，这是允许的。然而，该异常对应的栈轨迹并非 throw 语句的位置，而是新建异常的 位置。
    因此，这种做法可能会误导开发人员，使其定位到错误的位置。这也是为什么在实践中，我们往往
    选择抛出新建异常实例的原因。

- 1:使用异常捕获的代码为什么比较耗费性能? 因为构造异常的实例比较耗性能。这从代码层面很难理解，不过站在JVM的角度来看就简单了，因 为JVM在构造异常实例时需要生成该异常的栈轨迹。这个操作会逐一访问当前线程的栈帧，并且记 录下各种调试信息，包括栈帧所指向方法的名字，方法所在的类名、文件名，以及在代码中的第几 行触发该异常等信息。 虽然具体不清楚JVM的实现细节，但是看描述这件事情也是比较费时费力的。

- 2:fnally是怎么实现无论异常与否都能被执行的? 这个事情是由编译器来实现的，现在的做法是这样的，编译器在编译Java代码时，会复制fnally代 码块的内容，然后分别放在try-catch代码块所有的正常执行路径及异常执行路径的出口中。