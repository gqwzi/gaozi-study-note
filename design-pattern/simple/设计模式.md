### 1、简单工厂方法模式      
**【描述】** 建立一个工厂类，对实现了同一接口的一些类进行实例的创建      
**【代码】**        
1、创建一个接口
```java
public interface Sender{
    public void send();
}
```
2、创建2个实现类
```java
public class MailSender implements Sender{
    @Override
    public void send(){
        System.out.println("====mail send===");
    }
}

public class SmsSender implements Sender{
    @Override
    public void send(){
        System.out.println("======sms send===");
    }
}
```
3、创建一个工厂类
```java
public class SendFactory {
    public static  Sender produce(String type){
        if("mail".equals(type)){
            return new MailSender();
        }else if("sms".equals(type)){
            return new SmsSender();
        }else{
            System.out.println("请输入正确的类型");
            return null;
        }
    }
}
```     
测试类：
```java
public class Test{
    public static void main(String[] args){
      Sender sender = SendFactory.produce("mail");
      sender.send();
    }
}
```
> 备注：如果字符串type传入错误，则不能正确创建对象

### 2、抽象工厂模式        
**【描述】**简单工厂模式有个问题就是，类的创建依赖工厂类，也就是说，如果想要扩展程序，必须修改工厂类，而这违背了开闭原则，因此，从设计角度考虑，有一定的问题，如何解决？就用到工厂方法模式，创建一个工厂接口以及创建多个工厂实现类，这样一旦需要增加新的功能，只需要直接增加新的工厂实现类即可，不需要修改之前的代码。        
**【代码】**     
1、定义Sender接口
```java
public interface Sender{
    public void send();
}
```

2、两个实现类
```java
public class MailSender implements Sender{
    @Override
    public void send(){
        System.out.println("======mailSender send====");
    }
}
public class SmsSender implements Sender{
    @Override
    public void send(){
        System.out.println("======smsSender send====");
    }
}
```

3、一个工厂接口        
```java
public interface ProviderFactory{
    Sender produce();
}
```

4、两个工厂实现类
 ```java
public class MailSenderFactory implements ProviderFactory{
    @Override
    public Sender produce(){
        return new MailSender();
    }
}

public class SmsSenderFactory implements ProviderFactory{
    @Override
    public Sender produce(){
        return new SmsSender();
    }
}
```

测试类
```java
public class Test{
    public static void main(String[] args){
      ProviderFactory provider = new MailSenderFactory();
      Sender sender = provider.produce();
      sender.Send();
    }
}
```
> 备注：其实这个模式的好处就是，如果你想增加一个发送及时消息的功能，只需要加1个实现类实现Sender接口，然后再增加一个工厂类实现工厂providerFactory接口，就OK了，无需去改动代码！这样做，拓展性最好！      

### 3、单例模式
【描述】单例模式是java中最简单的设计模式。它的优点是：在内存里只有1个实例，减少了内存的开销，尤其是频繁的创建和销毁实例。省去了new的操作，降低了系统内存的使用频率，减轻了GC压力       
【代码】（只列举典型的）        
1、双重检索模式
```java
public class Singleton{
    //1、构造器私有化
    private Singleton(){};
    //2、创建一个成员变量
    private static Singleton instance = null;
    //3、给外界提供一个公共获取实例的方法
    public static Singleton getInstance(){
        if(singleton == null){
            synchronized (Singleton.class){
                if(Singleton == null){
                    instance = new Singleton();
                }
            }
        }
        return instance;
    }
}
```
2、内部类模式
```java
public class Singleton{
    //1、构造器私有化
    private Singleton();
    //2、使用一个静态内部类维护单例
    private static class SingletonFactory{
        private static Singleton instance = new Singleton();
    }
    //3、给外界提供一个获取实例的方法
    public static Singleton getInstance(){
        return SingletonFactory.instance;
    }
}
```
3、枚举类
```java
public enum Singleton{
    INSTANCE;
    public void doSomeThing(){};
}
```
> 备注：单例模式理解起来简单，但是具体实现起来还是有一定的难度，尤其是在多线程情况下保证线程安全。      
### 4、建造者模式     
【描述】 工厂模式是创建单个类的对象，而建造者模式是将各种产品集中起来进行管理，用来创建复合对象，所谓复合对象就是某个类具有不同的属性     
【代码】        
1、定义Sender接口
```java
public interface Sender{
    public void send();
}
```

2、两个实现类
```java
public class MailSender implements Sender{
    @Override
    public void send(){
        System.out.println("======mailSender send====");
    }
}
public class SmsSender implements Sender{
    @Override
    public void send(){
        System.out.println("======smsSender send====");
    }
}
```
```java
public class Bulider{
    private List<Sender> senderList = new ArrayList<>();
    
    public void produceMailSender(int count){
        for(int i = 0;i<count;i++){
            list.add(new MailSender());
        }
    }
    
    public void produceSmsSender(int count){
    		for(int i=0; i<count; i++){
    			list.add(new SmsSender());
    		}
    	}
}
```     
测试类：
```java
public class Test {
 
	public static void main(String[] args) {
		Builder builder = new Builder();
		builder.produceMailSender(10);
	}
}
```     
> 备注：从这点看出，建造者模式将很多功能集成到一个类里，这个类可以创造出比较复杂的东西。所以与工程模式的区别就是：工厂模式关注的是创建单个产品，而建造者模式则关注创建符合对象，多个部分。因此，是选择工厂模式还是建造者模式，依实际情况而定。        

### 5、原型模式      
【描述】原型模式是设计模式中最简单的一种模式。从名字即可看出，该模式的思想就是将一个对象作为原型，对其进行复制、克隆，产生一个和原对象类似的新对象。本小结会通过对象的复制，进行讲解。在Java中，复制对象是通过clone()实现的。        
【代码】        
```java
public class ProtoType implements Cloneable {
    public Object clone()throws CloneNotSupportedException {
        ProtoType protoType = (ProtoType) super.clone();
        return protoType;
    }
}
```     
> 备注：这个只是浅拷贝。很简单，一个原型类，只需要实现Cloneable接口，覆写clone方法，此处clone方法可以改成任意的名称，因为Cloneable接口是个空接口，你可以任意定义实现类的方法名，如cloneA或者cloneB，因为此处的重点是super.clone()这句话，super.clone()调用的是Object的clone()方法，而在Object类中，clone()是native的        
> 浅复制：将一个对象复制后，基本数据类型的变量都会重新创建，而引用类型，指向的还是原对象所指向的       

### 6、适配器模式     
【描述】适配器模式目的是将原来接口转换为客户端期望的另一个接口表示，用来消除由于接口不匹配所造成的类的兼容性问题，主要分为两类：对象适配器模式和接口适配器模式     
【代码1】对象适配器模式        
1、source类      
```java
public class Source{
    public void method1(){
          System.out.println("this is original method!");  
    };
}
```     
2、Targetable接口       
```java
public interface Targetable{
    //与原类中的方法相同
    public void method1();
    //新类的方法
    public void method2();
}
```     
3、适配Wrapper类        
```java
public class Wrapper  implements Targetable{
    private Source source;
    public Wrapper(Source source){
        super();
        this.source = source;
    }
    @Override
        public void method1(){
            source.method1();
        }
    @Override
    public void method2(){
        System.out.println("this is method2");
    }
}
```     
4、测试类   
```java
public class Test{
    public static void main(String[] args){
      Source source = new Source();
      Targetable target = new Wrapper(source);
      target.method1();
      target.metnod2();
    }
}           
```     
> 备注：有一个Source类，拥有一个方法，待适配，目标接口是Targetable，通过Adapter类，将Source的功能扩展到Targetable里       

【代码2】 接口适配模式            
1、定义Sourceable接口
```java
public interface Sourceable{
    public void method1();
    public void method2();
}
```     
2、抽象Wrapper2        
```java
public abstract class AbstractWrapper2 implements Sourceable{
    public void method1();
    public void method2();
}
```     
3、子sourceable类1、子sourceable类2     
```java
public class SourceSub1 extends AbstractWrapper2{
    public void method1(){
        System.out.println("the sourceable interface's first Sub1!"); 
    }
}

public class SourceSub2 extends AbstractWrapper2{
    public void method2(){
        System.out.println("the sourceable interface's second Sub2!"); 
    }
}
```     
4、测试类       
```java
public class Test{
    public static void main(String[] args){
      Sourceable source1 = new SourceSub1();
      Sourceable source2 = new SourceSub2();
      source1.method1();  
      source1.method2();  
      source2.method1();  
      source2.method2();  
    }
}
```     
> 备注：接口的适配器是这样的：有时我们写的一个接口中有多个抽象方法，当我们写该接口的实现类时，必须实现该接口的所有方法，这明显有时比较浪费，因为并不是所有的方法都是我们需要的，有时只需要某一些，此处为了解决这个问题，我们引入了接口的适配器模式，借助于一个抽象类，该抽象类实现了该接口，实现了所有的方法，而我们不和原始的接口打交道，只和该抽象类取得联系，所以我们写一个类，继承该抽象类，重写我们需要的方法就行        

### 7、装饰者模式     
【描述】顾名思义，装饰模式就是给一个对象增加一些新的功能，而且是动态的，要求装饰对象和被装饰对象实现同一个接口，并且被装饰对象要持有一个装饰对象的实例。        
【代码】        
1、原对象source类
```java
public class Source{
    public void method(){
        System.out.println("this is the origin method");
    };
}
```
2、原对象实现的接口Sourceable
```java
public interface Sourceable{
    public void method();
}
```
3、装饰类
```java
public class Decorator implements Sourceable{
    private Sourceable source;
    public Decorator(Sourceable source){
        super();
        this.source = source;
    }
    @Override
    public void method(){
        System.out.println("=====before decortar ======");
        source.method();
        System.out.println("=====after decortar ======");
    }
}
```
4、测试类       
```java
public class Test{
    public static void main(String[] args){
      Decortor decortor = new Decorator(new Source());
      decortor.method();
    }
}
```
> 备注：装饰器模式的应用场景：        
1、需要扩展一个类的功能        
2、动态的为一个对象增加功能，而且还能动态撤销。（继承不能做到这一点，继承的功能是静态的，不能动态增删。）       

### 8、代理模式      
【描述】每个模式的名字都代表了该模式的作用，代理模式顾名而思义就是对原有类起一个代理的作用，比如打官司时我们要请律师来帮我们，因为律师比我们更专业       
【代码】        
1、source类
```java
public class Source{
    public void method(){
        System.out.println("this is origin method");
    }
}
```
2、sourceable类
```java
public interface Sourceable{
    public void method();
}
```
3、代理类
```java
public class ProxySource implements Sourceable{
    private Source source;
    public ProxySource(){
        super();
        source = new Source();
    }
    @Override
    public void method(){
        System.out.println("before proxySource");
        source.method();
        System.out.println("after proxySource");
    }
}
```
4、测试类
```java
public class Test{
    public static void main(String[] args){
      Sourceable source = new ProxySource();
      source.method();
    }
}
```
> 备注：代理模式的应用场景：已有的方法在使用时需要对原有的方法进行改进，有2种办法     
1、修改原有的方法来适应。这样违反了‘开闭原则’        
2、采用一个代理类调用原有的方法，且对产生的结果进行控制。这就是代理模式。

### 9、外观模式      
【描述】        
外观模式是为了解决类与类之间的依赖关系，像spring一样，类与类之前的关系可以通过配置文件来维护，而外观模式就是把它们的关系放在facade类中，降低了类之间的耦合度。 （以计算机启动过程为例）      
【代码】        
```java
public class CPU{
    public void startUp(){
        System.out.println("cup startup");
    }
    public void shutDown(){
        System.out.println("cpu shutDown");
    }
}
```     
```java
public class Memory{
    public void startUp(){
        System.out.println("memory startup");
    }
    public void shutDown(){
        System.out.println("memory shutDown");
    }
}
```
```java
public class Disk{
    public void startUp(){
        System.out.println("disk startUp");
    }
    public void shutDown(){
        System.out.println(disk shutDown);
    }
}
```
```java
public class Computer{
    private CPU cpu;
    private Memory memory;
    private Disk disk;
    public Computer(){
        this.cpu = new CPU();
        this.memory = new Memory();
        this.disk = new Disk();
    }
    public void startUp(){
        cpu.startUp();
        memory.startUp();
        disk.startUp();
    }
    public void shutDown(){
        cpu.shutDown();
        memory.shutDown();
        disk.shutDown();
    }
}
```
```java
public class Test{
    public static void main(String[] args){
    Computer computer = new Computer();
    computer.startUp();
    computer.shutDown();
    }
}
```
> 备注：       
1.如果我们没有Computer类，那么cpu、memory、disk相互之间将会相互持有实例，产生关系，这样会造成严重的依赖，修改一个类，可能会带来其他类的修改，这不是我们想看到的，有了computer类，他们之间的关系被放在了computer类里，这样就起到了解耦的作用，这，就是外观模式
2.其实我们最常见的controller、service、dao就是外观模式，试想如果没有service，那么controller里需要组合多少的dao        

### 10、桥接模式     
【描述】桥接模式就是将事物与具体实现分开，使他们可以各自独立的变化。桥接的用意是*将抽象化与实现化解耦，使得二者可以独立变化*，像我们常用的JDBC桥DriverManager一样，JDBC在进行数据库连接的时候，在各个数据库之间切换时，基本不需要动太多的代码，甚至丝毫不用动，原因是JDBC提供了统一接口，每个数据库提供各自的实现，用一个叫做数据库驱动的程序来桥接就行了。     
【代码】        
定义一个sourceAble接口
```java
public interface Sourceable{
    public void method();
}
```
定义两个实现类
```java
public class SourceSub1 implements Sourceable{
    @Override
    public void method(){
        System.out.println("this is sub1");
    }
}

public class SourceSub2 implements Sourceable{
    @Override
    public void method(){
        System.out.println("this is sub2");
    }
}
```
定义一个桥bridge
```java
public abstract class Bridge{
    private Sourceable source;
    public void method(){
        source.method();
    }
    public Sourceable getSource(){
        return source;
    }
    public void setSource(Sourceable source){
        this.source = source;
    }
}
```
定义myBridge
```java
public class MyBridge extends Bridge{
    @Override
    public void method(){
        getSource().method();
    }
}
```
测试类
```java
public class Test{
    public static void main(String[] args){
      Bridge bridge = new MyBridge();
      //调用第一个对象
      Sourceable source1 = new SourceSub1();
      bridge.setSource(source1);
      bridge.method();
      
      //调用第二个对象
      Sourceable source2 = new SourceSub2();
      bridge.setSource(source2);
      bridge.method();
    }
}
```
> 备注：这样，就通过对bridge的调用，实现了对接口sourceable的实现类sourceSub1和sourceSub2的调用。JDBC所采用的就是这种模式。

### 11、组合模式         
【描述】组合模式又叫‘部分—整体’模式，该模式在处理树型结构问题时较方便        
【代码】        
```java
public class TreeNode{
    private String name;
    private TreeNode parent;
    private Vector<TreeNode> child = new Vecotar();
    public TreeNode(String name){
        this.name = name;
    }
    public String getName(){
        return this.name;
    }
    public void setName(String name){
        this.name = name;
    }
    public TreeNode getParent(){
        return parent;
    }
    public void setParent(TreeNode parent){
        this.parent = parent;
    }
    //添加孩子节点
    public void add(TreeNode treeNode){
        child.add(treeNode);
    }
    //删除孩子节点
    public void remove(TreeNode treeNode){
        child.remove(treeNode);
    }
    //取得孩子节点
    public Enumeration<TreeNode> getChild(){
        return child.elements();
    }
}
```
测试类
```java
public class Tree{
    TreeNode root = null;
    public Tree(String name){
        root = new TreeNode(name);
    }
    public static void main(String[] args){
      Tree tree = new Tree("A");
      TreeNode treeNodeB = new TreeNode("B");
      TreeNode treeNodeC = new TreeNode("C");
      
      treeNodeB.add(treeNodeC);
      tree.root.add(treeNodeB);
      System.out.println("build the tree finished");
    }
}
```
> 备注：使用场景是将多个对象组合在一起进行操作，常用于表示树形结构中，例如二叉树，数等。

### 12、享元模式     
【描述】享元模式的主要目的是实现对象的共享，即共享池，当系统中对象多的时候可以减少内存的开销      
【代码】
```java
public class ConnectionPool{
    private Vector<Connect> connPool = null;
    //共有属性
    private String url = "jdbc:mysql://localhost:3306/test";
    private String username = "test";
    private String password = "123456";
    private String driverClassName = "com.mysql.jdbc.Driver";
    
    private int maxSize = 100;
    Connection conn;
    
    //构造器，初始化时做一些工作
    public ConnectionPool(){
        connPool = new Vector<Conntection>(maxSize);
        for(int i = 0;i<maxSize;i++){
            try{
            Class.forName(driverClassName)
            conn = DriverManager.getConnection(url,username,password);
            connPool.add(conn);
            }catch(SQLException e){
                e.printStackTrace();
            }
        }
    }
    //返回到连接池
    public synchronized void release(){
        connPoll.add(conn);
    }
    //返回连接池中的一个数据库连接
    public synchronized Coonection getConnection(){
        if(connPool.size() > 0){
            Connection conn = connPool.get(0);
            connPool.remove(conn);
            return conn;
        }else{
            return null;
        }
    }
}
```
> 备注：通过连接池的管理，实现了数据库连接的共享，不需要每一次都重新创建连接，节省了数据库重新创建连接的开销，提升了系统性能。        

### 12、策略模式     
【描述】 策略模式定义了一系列算法，并将每个算法封装起来，使他们可以相互替换，且算法的变化不会影响到使用算法的客户。需要设计一个接口，为多个实现类提供统一的方法，多个实现类实现该接口。        
【代码】
```java
public interface Caculator{
    public int caculate(int a,int b);
}
```     
```java
public class Plus implements Caculator{
    @Override
    public int caculate(int a,int b){
        return a + b;
    }
}
```
```java
public class Minus implements Caculator{
    @Override
    public int caculate(int a,int b){
        return a - b;
    }
}
```
```java
public class Multiply implements Caculator{
    @Override
    public int caculate(int a,int b){
        return a * b;
    }
}
```
测试类
```java
public class Test{
    public static void main(String[] args){
      int a = 1;
      int b = 2;
      Caculator caculator = new Plus();
      int result = caculator.caculate(a,b);
      System.out.println(result);
    }
}
```
> 备注：策略模式的决定权在用户，系统本身提供不同算法的实现，新增或者删除算法，对各种算法做封装。因此策略模式多用在算法决策中，外部用户只需要决定用哪个算法即可！       
### 13、【模板方法模式】
【描述】 
模板方法模式，一般是为了统一子类的算法实现步骤，所使用的一种手段或者说是方式。它在父类中定义一系列算法的步骤，而将具体的实现都推迟到子类
最典型的就是一个接口，一个抽象父类，父类中有一些抽象方法，而在子类中一一去实现这些方法。        
下面举例        
```java
public interface PageBulider{
    String buildHtml();
}
```     
假如我们不使用模板方法模式，那么每个子类实现出来的千奇百怪，而且步骤也乱七八糟，不利于维护和扩展，所以我们可以使用模板方法设计模式。将这个过程制定好，将具体填充的内容
交给子类，这样这些子类生成的html就会比较一致。       
```java
public abstract class AbstractPageBuilder{
    private StringBuffer sb = new StringBuffer();
    public String buildHtml{
        //首先加入doctype,因为都是html页面,所以我们父类不需要推迟给子类实现,直接在父类实现
        sb.append("<!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML 1.0 Transitional//EN\" \"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd\">");
        //页面下面就是成对的一个HTML标签，我们也在父类加入,不需要给子类实现
        sb.append("<html xmlns=\"http://www.w3.org/1999/xhtml\">");
        //下面就应该是head标签里的内容了,这个我们父类做不了主了,推迟到子类实现,所以我们定义一个抽象方法,让子类必须实现
        appendHeader();
        //下面是body的内容了，我们父类依然无法做主，仍然推迟到子类实现
        appendBody();
        sb.append("</html>");
        return sb.toString();
    }
    //第一个抽象模板方法
    protected abstract void appendHeader(StringBuffer sb);
    //第二个抽象模板方法
    protected abstract void appendBody(StringBuffer sb);
}
```    
```java
public class MyBuildPage extends AbstractPageBuilder{
    protected abstract void appendHeader(StringBuffer sb){
        sb.append("<head><title>我是header</title></head>")
    }
    protected abstract void appendBody(StringBuffer sb){
        sb.append("<body>我是body hello world</body>");
    }
}
```     
```java
public class Test{
    public static void main(String[] args){
      PageBuilder apd = new MyBuildPage();
      System.out.println(apd.buildHtml());;
    }
}
```     
【备注】通常情况下，模板方法模式用于定义构建某个对象的步骤与顺序，或者定义一个算法的骨架。另外，java的classloader即类加载器就使用了模板方法模式。
在ClassLoader中定义的算法顺序是。
```
 1，首先看是否有已经加载好的类。

 2，如果父类加载器不为空，则首先从父类类加载器加载。

 3，如果父类加载器为空，则尝试从启动加载器加载。

 4，如果两者都失败，才尝试从findClass方法加载。
 ```
> 这是JDK类加载器的双亲委派模型，即先从父类加载器加载，直到继承体系的顶层，否则才会采用当前的类加载器加载。这样做的目的刚才已经说了，是为了JVM中类的一致性。

14、【观察者模式】		
【描述】
