### 1、简单工厂方法模式      
**【描述】** 建立一个工厂类，对实现了同一接口的一些类进行实例的创建      
**【代码】**        
1、创建一个接口
```java
public interface Sender{
    public void send();
}
```
2、创建2个实现类
```java
public class MailSender implements Sender{
    @Override
    public void send(){
        System.out.println("====mail send===");
    }
}

public class SmsSender implements Sender{
    @Override
    public void send(){
        System.out.println("======sms send===");
    }
}
```
3、创建一个工厂类
```java
public class SendFactory {
    public static  Sender produce(String type){
        if("mail".equals(type)){
            return new MailSender();
        }else if("sms".equals(type)){
            return new SmsSender();
        }else{
            System.out.println("请输入正确的类型");
            return null;
        }
    }
}
```     
测试类：
```java
public class Test{
    public static void main(String[] args){
      Sender sender = SendFactory.produce("mail");
      sender.send();
    }
}
```
> 备注：如果字符串type传入错误，则不能正确创建对象

### 2、抽象工厂模式        
**【描述】**简单工厂模式有个问题就是，类的创建依赖工厂类，也就是说，如果想要扩展程序，必须修改工厂类，而这违背了开闭原则，因此，从设计角度考虑，有一定的问题，如何解决？就用到工厂方法模式，创建一个工厂接口以及创建多个工厂实现类，这样一旦需要增加新的功能，只需要直接增加新的工厂实现类即可，不需要修改之前的代码。        
**【代码】**     
1、定义Sender接口
```java
public interface Sender{
    public void send();
}
```

2、两个实现类
```java
public class MailSender implements Sender{
    @Override
    public void send(){
        System.out.println("======mailSender send====");
    }
}
public class SmsSender implements Sender{
    @Override
    public void send(){
        System.out.println("======smsSender send====");
    }
}
```

3、一个工厂接口        
```java
public interface ProviderFactory{
    Sender produce();
}
```

4、两个工厂实现类
 ```java
public class MailSenderFactory implements ProviderFactory{
    @Override
    public Sender produce(){
        return new MailSender();
    }
}

public class SmsSenderFactory implements ProviderFactory{
    @Override
    public Sender produce(){
        return new SmsSender();
    }
}
```

测试类
```java
public class Test{
    public static void main(String[] args){
      ProviderFactory provider = new MailSenderFactory();
      Sender sender = provider.produce();
      sender.Send();
    }
}
```
> 备注：其实这个模式的好处就是，如果你想增加一个发送及时消息的功能，只需要加1个实现类实现Sender接口，然后再增加一个工厂类实现工厂providerFactory接口，就OK了，无需去改动代码！这样做，拓展性最好！      

### 3、单例模式
【描述】单例模式是java中最简单的设计模式。它的优点是：在内存里只有1个实例，减少了内存的开销，尤其是频繁的创建和销毁实例。省去了new的操作，降低了系统内存的使用频率，减轻了GC压力       
【代码】（只列举典型的）        
1、双重检索模式
```java
public class Singleton{
    //1、构造器私有化
    private Singleton(){};
    //2、创建一个成员变量
    private static Singleton instance = null;
    //3、给外界提供一个公共获取实例的方法
    public static Singleton getInstance(){
        if(singleton == null){
            synchronized (Singleton.class){
                if(Singleton == null){
                    instance = new Singleton();
                }
            }
        }
        return instance;
    }
}
```
2、内部类模式
```java
public class Singleton{
    //1、构造器私有化
    private Singleton();
    //2、使用一个静态内部类维护单例
    private static class SingletonFactory{
        private static Singleton instance = new Singleton();
    }
    //3、给外界提供一个获取实例的方法
    public static Singleton getInstance(){
        return SingletonFactory.instance;
    }
}
```
3、枚举类
```java
public enum Singleton{
    INSTANCE;
    public void doSomeThing(){};
}
```
> 备注：单例模式理解起来简单，但是具体实现起来还是有一定的难度，尤其是在多线程情况下保证线程安全。      
### 4、建造者模式     
【描述】 工厂模式是创建单个类的对象，而建造者模式是将各种产品集中起来进行管理，用来创建复合对象，所谓复合对象就是某个类具有不同的属性     
【代码】
1、定义Sender接口
```java
public interface Sender{
    public void send();
}
```

2、两个实现类
```java
public class MailSender implements Sender{
    @Override
    public void send(){
        System.out.println("======mailSender send====");
    }
}
public class SmsSender implements Sender{
    @Override
    public void send(){
        System.out.println("======smsSender send====");
    }
}
```
```java
public class Bulider{
    private List<Sender> senderList = new ArrayList<>();
    
    public void produceMailSender(int count){
        for(int i = 0;i<count;i++){
            list.add(new MailSender());
        }
    }
    
    public void produceSmsSender(int count){
    		for(int i=0; i<count; i++){
    			list.add(new SmsSender());
    		}
    	}
}
```     
测试类：
```java
public class Test {
 
	public static void main(String[] args) {
		Builder builder = new Builder();
		builder.produceMailSender(10);
	}
}
```     
> 备注：从这点看出，建造者模式将很多功能集成到一个类里，这个类可以创造出比较复杂的东西。所以与工程模式的区别就是：工厂模式关注的是创建单个产品，而建造者模式则关注创建符合对象，多个部分。因此，是选择工厂模式还是建造者模式，依实际情况而定。        
### 5、原型模式      
